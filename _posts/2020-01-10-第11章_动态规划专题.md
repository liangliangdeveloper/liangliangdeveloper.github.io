---
layout: article
mathjax: true
articles:
  excerpt_type: html
tags: 算法笔记
key: c11algo
comment:true
---

## 11.1 动态规划的递归写法和递推写法

### 11.1.1 什么是动态规划

**动态规划（Dynamic Programing，DP）**是一种用来解决一类**最优化**问题的算法思想。动态规划将一个复杂的问题分解为若干个子问题，通过综合子问题的最优解来得到原问题的最优解。需要注意的是，动态规划会将每个求解过得子问题的解记录下来，这样下次就可以直接使用。

一般可以用递归或者递推算法。递归写法又被称作**记忆化搜索**。

### 11.1.2 动态规划的递归写法

**理解如何记录子问题的解，来避免下次遇到相同子问题时的重复计算**

斐波那契数列计算为例：

```c++
int F(int n){
    if(n == 0 || n == 1) return 1;
    else return F(n-1) + F(n-2);
}
```

为**避免重复计算**，开一个一位数组dp，保存已经计算过的结果，dp[n]=-1来表示还没有计算过。

```c++
int F(int n) {
    if(n == 0 || n == 1) return 1;
    if(dp[n] != -1) return dp[n];
    else {
        dp[n] = F(n-1) + F(n-2);
        return dp[n];
    }
}
```

再次碰到需要计算相同内容时，就可以直接利用上次的结果，省去无效计算。**记忆化搜索**的由来。复杂度从O(n2)降到了O(n)。

如果一个问题可以被分解为若干子问题，且这些子问题会重复出现，那么就称这个问题拥有**重叠子问题（Overlapping Subproblems）**

### 11.1.3 动态规划的递推写法

**数塔问题**：将一些数字排成塔的形状，第n层有n个数字。现在要从第一层走到第n层，每次只能走向下一层连接的两个数字的一个，最后将路径上所有数字相加后最大值是多少？

![1574765823063](..\src\images\1574765823063.png)

不妨令dp\[i][j]是第i行第j个数字出发到达底层的所有路径中的最大和，这样dp\[1][1]就是我们最后想要的答案。求dp\[1][1]就要先求两个子问题dp\[2][1]和dp\[2][2]。进行了一次**决策**，走数字5的左侧还是右侧。写成式子就是：
$$
dp[i][j]=max(dp[i+1][j],dp[i+1][j+1]) + f[i][j]
$$
把dp\[i][j]称为问题的**状态**，上面的式子称为**状态转移方程**，它把dp\[i][j]转移为了dp\[i+1][j]和dp\[i+1][j+1],并且dp\[i][j]只和i+1层有关。最后一层dp\[n][j]=f\[n][j]，把这种可以直接确定其结果的称为**边界**。

下面是动态规划代码：

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 1000;
int f[maxn][maxn], dp[maxn][maxn];
int main() {
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {
            scanf("%d", &f[i][j]);
        }
    }
    
    //边界
    for(int j = 1; j <= n; j++) {
        dp[n][j] = f[n][j];
    }
    
    for(int i = n - 1; i >= 1; i--) {
        for(int j = 1; j <= i; j++) {
            dp[i][j] = max(dp[i + 1][j],dp[i + 1][j + 1]) + f[i][j];
        }
    }
    printf("%d\n", dp[1][1]);
    return 0;
}
```

**递推写法**：计算方式是**自底向上（Bottom-up Approach）**从边界开始，不断向上解决问题，直到解决目标问题。

**递归写法**：计算方式是**自顶向上（Top-down Approach）**，从目标问题开始，将它分解为子问题的组合，直到分解到边界。

引申一个概念：如果一个问题的最优解可以由子问题的的最优解构造出来，那么称这个问题拥有**最优子结构（Optimal Substructure）**。一个问题有最优子结构才能使用动态规划总结。

**一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决**

下面指出两个概念的区别：

①分治与动态规划。分治不存在子问题重叠（归排和快排），动态规划出现重叠子问题。

②贪心与动态规划。贪心法也是自顶向上，但是并不等待子问题求解完之后再去选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。以一种单链流水方式进行。

## 11.2 最大连续子序列和

```
给定一个数字序列A1，A2，...，An，求i，j使得Ai+Aj最大，输出这个最大值。
```

步骤1：dp\[i]指的是A[i]作为数组末尾的连续序列最大和。

步骤2：作如下考虑，有两种情况：

①这个最大和的连续序列只有一个元素，即从A[i]开始，A[i]结尾；

②这个最大和的连续序列有多个元素，即从前面某处A[p]开始，直到A[i]结尾。

第一种情况，最大和就是A[i]本身。

第二种情况，最大和是dp[i-1]+A[i],只有这两种情况，于是得到状态转移方程：
$$
dp[i]=max{A[i],dp[i-1]+A[i]}
$$
**状态的无后效性**是指，当前状态记录了历史信息，一旦当前状态确定，就不会再改变，且未来的决策只能在一个已有的一个或多个状态的基础上进行，历史信息只能通过已有状态去影响未来的决策。

## 11.3 最长不下降子序列（LIS）

最长不下降子列（Longest Increasing Sequence，LIS）：

```
在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降（非递减）的。
```

令dp[i]表示以A结尾的最长不下降子序列长度，那么就有两种长度。

①如果在A[i]之前的元素A\[j](j<i)，使得A[j]<=A[i]且dp[j]+1>dp[i]（即把A[i]跟在以A[j]结尾的LIS后面时能比当前以A[i]结尾的LIS长度更长），那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列（dp[i]=dp[j]+1).

②如果A[i]之前的每一个元素都比A[i]大，那么A[i]就只能自己形成一条LIS，长度为1.

状态转移方程：
$$
dp[i]=max\{1,dp[i]\}
(j=1,2,...i-1\&\&A[j]<A[i])
$$

## 11.4 最长公共子序列（LCS）

最长公共子序列（Longest Common Subsequent，LCS）

```
给定两个字符串（或数字序列）A和B，求一个字符串使得这个字符串是A和B的最长公共部分（子序列可以不连续）。
```

dp\[i][j]表示字符串Ai号位与字符串Bj号位LCS长度（下标从1开始）那么可以根据A[i]和B[j]的情况，分为两种决策：

①若A[i]==B[i]，则字符串B的LCS增加了一位，即有dp\[i][j]=dp\[i-1][j-1]+1;

②若A[i]!=B[j]，则字符串A的i号位和B的j号位之前的LCS无法延长，因此继承dp\[i-1][j]和dp\[i][j-1]中较大的值。即dp\[i][j]=max{dp\[i-1][j],dp\[i][j-1]}.

状态转移方程：

![1574774476475](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\1574774476475.png)

## 11.5 最长回文子串

```
给出一个字符串S，求S的最长回文子串的长度。
```

令dp\[i][j]表示S\[i]至S[j]所表示的子串是否是回文串，是则是1，不是则是0.这样根据S[i]是否等于S[j]，把转移情况分为两类：

①若S[i]==S[j]，那么只要S[i+1]至S[j-1]是回文子串，S[i]至S[j]就是回文子串，如果不是，那么新的也不是。

②若S[i]!=S[j]，那么S[i]至S[j]也不是回文子串。

写出状态转移方程：

![1574774847613](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\1574774847613.png)

还有一个问题没有解决：如果按照i和j的顺序来枚举子串的两个端点，然后更新dp\[i][j]，会无法保证dp\[i+1][j-1]已经计算过，从而无法得到正确的dp\[i][j]。事实上，无论怎么调整i和j都无法调和这个矛盾，需要新的枚举方式。

根据递推写法从边界出发的原理，注意到边界表示的是长度为1和2的子串，并且每次转移时都对子串的长度减了1，因此不妨考虑按子串的长度和初始位置进行枚举，即第一遍先把长度为3的子串dp值求出，第二遍求长度为4的dp子串......这样就可以避免状态无法转移的问题。可以先枚举子串长度L，再枚举左端点i，这样右端点i+L-1也可以直接得到。

## 11.6 DAG最长路

求解DAG的关键路径。本节主要解决两个问题：

①求整个DAG中的最长路径（即不固定起点和终点）

②固定终点，求DAG的最长路径

首先讨论第一个问题：**给定一个有向无环图，怎样求解整个图所有路径中权值之和最大那一条**

dp[i]表示从i号顶点出发能获得的最长路径长度。如何求解dp[i]数组？
$$
dp[i]=max\{dp[j]+length[i->j]|(i,j)∈E\}
$$
上面的思路需要按照逆拓扑顺序求解数组，也有不用求出逆拓扑序列也能计算dp数组的方法，那就是递归。图使用邻接矩阵求解：

```c++
int DP(int i) {
    if(dp[i] > 0) return dp[i];
    for(int j = 0; j < n; j++) {
        if(G[i][j]!=INF) {
            dp[i] = max(dp[i], DP(j) + G[i][j])
        }
    }
    return dp[i];
}
```

实现时将整个数组dp初始化为0.

回忆在Dijkstra算法中是如何求解最短路径的？可以把这种思想用于求最长路径上——开一个int型choice数组记录最长路径上的后继节点，因此使用迭代即可（递归也可以）

对一般动态规划问题而言，如果需要得到具体的最优方案，可以采用类似的方法，即**记录每次决策所选择的策略，然后再dp数组计算完毕后根据具体情况进行递归或者迭代来获取方案**。

跟进一步，模仿字符串来定义路径的字典序，如何选取字典序最小的那条（上面已经自动实现了）。

第二个问题：**固定终点，求DAG的最长路径长度**。

有了上面的经验，可以改为令dp[i]是i顶点出发到T的最长路径长度。

$$
dp[i]=max\{dp[j]+length[i->j]|(i,j)∈E\}
$$
增加了终点为T的描述。两个问题的不同点在与**边界**。dp[T]=0，但是不能给整个dp赋值为0。有些顶点无法到达T，这个时候0就会带来歧义，可以设定为-INF来表达无法到达。这是via数组表示顶点是否被计算。

```c++
int DP(int i) {
    if(vis[i]) return dp[i];
    vis[i] = true;
    for(int j = 0; j < n; j++) {
        if(G[i][j] != INF) {
            dp[i] = max(dp[i], DP[j] + G[i][j]);
        }
    }
    return dp[i];
}
```

**矩形嵌套问题**：给出n个矩形的长和宽，定义矩形的嵌套关系为：如果有两个矩形A和B，A的长宽为a，b，B的长宽为c，d，且满足a<c，b<d，或者a<d,b<c，则称矩形A可以嵌套于矩形B内。现在要求一个矩形序列，使得这个序列中任意两个相邻的矩形满足前面的矩形可以嵌套于后一个矩形内，且序列长度最长。有多个就按照字典序输出。

这就是典型的DAG最长问题，将矩形看做顶点，嵌套关系看做有向边，边权为1，转换为最长路问题。

## 11.7  背包问题

### 11.7.1 多阶段动态规划问题

有一类动态规划问题，它可以描述为若干个有序的阶段，且每个阶段之和上一个阶段的状态有关，把这一类问题称为多阶段动态规划问题。对这种问题，只需要从第一个问题开始，按照阶段的顺序解决每个阶段中状态的计算，就可以得到最后一个阶段的解。01背包问题就是这样的一个例子。

### 11.7.2 01背包问题

问题是这样的：

```
有n件物品，每件物品重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包总价值最大。其中每种商品仅有一件。
```

令dp\[i][v]表示前i件物品恰好装入容量为v所能获得的最大价值。

对于第i件商品选择有两种策略：

①不放第i件物品，那么问题转换为前i-1件物品装入恰好容量为v的背包所能获得的最大价值。也即dp\[i-1][v]

②放第i件物品，那么问题转化为前i-1物品恰好装入容量为v-w[i]的背包中所能获得的最大价值，也即dp\[i-1][v-w[i]]+c[i]

因此
$$
dp[i][v]=max\{dp[i-1][v],dp[i-1][v-w[i]]+c[i]\}(1<=i<=n,w[i]<=v<=V)
$$
上面就是状态转移方程，边界是dp\[0][v]=0，把整个数组递推出来。因为dp\[i][v]是恰好为v的情况，所以需要枚举dp\[n][v],取最大值才是最后结果。

```c++
for(int i = 1; i <= n; i++) {
    for(int v = w[i]; v <= V; V++) {
        dp[i][v]=max(dp[i][v],dp[i-1][v-w[i]]+c[i]);
    }
}
```

时间复杂度已经无法优化，但是空间复杂度可以优化。注意到d\[i][v]计算只需要dp\[i-1][v]左侧部分数据（正上方和左上方），当计算dp\[i+1][]的部分时，dp[i-1]数组完全用不到，一次不妨直接开一个一维数组，枚举方向改变为i从1到n，v从V到0（逆序），状态转移方程改为

$$
dp[v]=max\{dp[v],dp[v-w[i]]+c[i]\}(1<=i<=n,w[i]<=v<=V)
$$

这种技巧称为**滚动数组**。

代码如下：

```c++
for(int i=1; i<=n; i++) {
    for(int v=V; v>=0; v--) {
        dp[v]=max(dp[v],dp[v-w[i]]+c[i]);
    }
}
```

### 11.7.3 完全背包问题

唯一区别是每个物品有无穷件。

和01背包问题一样，完全背包问题的每种物品都有两种策略，但是也有不同点，对于第i件物品来说：

①不放第i件物品，那么dp\[i][v]=dp\[i-1][v]，这跟01背包问题是一样的；

②放第i件物品。这里处理和01背包不同，完全背包问题转移到dp\[i][v-w[i]]，直到v-w[i]不能保持大于等于0为止。

**状态转移方程**：
$$
dp[i][v]=max(dp[i-1][v],dp[i][v-w[i]]+c[i])
$$
边界：dp\[0][v]=0;

也可以写为一维形式：
$$
dp[v]=max(dp[i-1][v],dp[i][v-w[i]]+c[i])
$$
边界：dp[v]=0;

```c++
for(int i=1; i<=n; i++) {
    for(int v=w[i]; v<=V; v++) {   //正向枚举
        dp[v]=max(dp[v],dp[v-w[i]]+c[i]);
    }
}
```

## 11.8 总结

当题目与序列或者字符串（记为A）有关时，可以考虑把状态设计成下面两种形式，然后根据端点特点去考虑状态转移方程：

> ①令dp[i]表示以A[i]结尾（或开头）的×××
>
> ②令dp\[i][j]表示A[i]至A[j]区间的×××
>
> ×××均为原问题的表述。

分析题目中的状态需要几维来表示，然后对其中的每一维采取下面某一个表述：

> ①恰好为i
>
> ②前i

在每一维的含义设置完毕之后，dp数组的含义就可以设置为“令dp数组表示恰好为i（或前i），恰好为j（或前j）的×××”，其中×××为原问题的的描述。接下来就可以通过端点的特点去考虑状态转移方程