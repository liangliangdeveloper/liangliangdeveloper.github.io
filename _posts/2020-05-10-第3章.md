---
layout: article
title: 安卓开发 第3章 UI开发
mathjax: true
articles:
  excerpt_type: html
tags: [Android]
key: android3
comment: true
---

# 安卓开发 第3章 UI开发

## 3.1 如何编写程序界面

可视化编辑制作出来的界面不具有很好的屏幕适配性，因此我们要使用XML的方式编写界面。

## 3.2 常用控件的使用方法

### 3.2.1 TextView

修改XML中的代码：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/text_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="This is Text View"/>

</LinearLayout>
```

layout_width和layout_height有3个参数：match_parent,fill_parent和wrap_content.但是默认是左对齐，我们需要设定gravity，有top，buttom，left，right，center等参数，可以用|指定多个参数，例如center相当于center_vertical|center_horizontal。

```xml
android:gravity="center"
```

textSize和textColor可以控制大小和颜色，大小单位为sp。

### 3.2.2 Button

可以关闭默认转大写，属性textAllCaps改为false即可。

监听器的注册有两种方式：

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button_1);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //实现逻辑
            }
        });
    }
}
```

不喜欢匿名类的方式注册监听器，可以用接口的方式来实现注册。

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button_1);
        button.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button_1:
                //逻辑
                break;
            default:
                break;
        }
    }
}
```

### 3.2.3 EditText

用户可以输入内容，并对内容进行处理。

```xml
<EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Type something here"
        />
```

可以用maxLines属性指定最大行数，防止wrap_content"带来的问题。

```java
public class MainActivity extends AppCompatActivity{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button_1);
        final EditText editText = (EditText) findViewById(R.id.edit_text);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String s = editText.getText().toString();
                Toast.makeText(MainActivity.this,s,Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```

EditText和Button的交互示例代码。

### 3.2.4 ImageView

需要准备好一些图片。但是默认的drawable没有给分辨率，因此我们需要新建drawable-xhdpi目录。

```xml
<ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/img_1"/>
```

我们也可以动态的更改图片：

```java
public class MainActivity extends AppCompatActivity{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button_1);
        final EditText editText = (EditText) findViewById(R.id.edit_text);
        final ImageView imageView = (ImageView) findViewById(R.id.image_view);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                imageView.setImageResource(R.drawable.img_2);
            }
        });
    }
}
```

使用setImageResource即可。

### 3.2.5 ProgressBar

```xml
<ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        />
```

但是什么时候让数据加载完消失，我们可以控制Android控件visibility的三个属性：visible，invisible和gone。visible表示控件可见，invisible表示不可见，但是仍然占据着那一块空间，gone表示不可见并且不占据空间。

```
button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if(progressBar.getVisibility() == View.GONE){
                    progressBar.setVisibility(View.VISIBLE);
                } else {
                    progressBar.setVisibility(View.GONE);
                }
            }
        });
```

同样我们可以通过style属性设置为水平进度条，并用max值给定最大值：

```java
 <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        style="@style/Widget.AppCompat.ProgressBar.Horizontal"
        android:max="100"
        />
```

此时我们可以点一次按钮就给进度加10：

```java
public void onClick(View v) {
                int progress = progressBar.getProgress();
                progress = progress + 10;
                progressBar.setProgress(progress);
            }
```

### 3.2.6 AlertDialog

可以在当前的界面弹出对话框，置顶于所有元素之上，屏蔽掉其他控件的交互能力。例如防止误删内容。

```java
public void onClick(View v) {
                AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);
                dialog.setTitle("This is Dialog");
                dialog.setMessage("Something important.");
                dialog.setCancelable(false);
                dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {

                    }
                });
                dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {

                    }
                });
                dialog.show();
            }
        });
```

调用AlertDialog.Builder创建实例，设置标题，内容，是否可以取消。调用setPositiveButton设计点击事件。最后用show展示出来。

### 3.2.7 ProgressDialog

和AlertDialog类似，只不过会在对话框显示进度条，表示当前操作比较消耗。

```java
public void onClick(View v) {
                ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);
                progressDialog.setTitle("ProgressDialog");
                progressDialog.setMessage("Loading");
                progressDialog.setCancelable(true);
                progressDialog.show();
            }
```

如果在setCancelable传入false，那么back键不可用。一定要做好代码控制，数据加载完成后使用dismiss方法关闭对话框，否则就会一直存在。

## 3.3 详解4种基本布局

布局是一种可以可以用于放置很多控件的容器，同时布局也可以嵌套布局。新建项目

### 3.3.1 线性布局

LinearLayout又被称为线性布局，可以指定方向orientation，有vertical和horizontal。如果是horizontal，那么宽度不可以match_parent，如果是vertical，那么高度不可以match_parent。

layout_gravity指定控件在布局的对齐方式。但horizontal的时候垂直的对齐才会生效，vertical的时候水平的对齐才会生效。

接下来是weight属性，对于屏幕适配有着重要的作用。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <EditText
        android:id="@+id/edit_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:hint="Type Something"/>
    
    <Button
        android:id="@+id/button"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Send"
        />

</LinearLayout>
```

![1582788275551](\src\images\1582788275551.png)

此时横向宽度为0dp，只是一种规范写法罢了。我们使用layout_weight来平分水平宽度。他会按照权值来进行比例分配。

我们还可以指定按钮的宽度为wrap_content，这样button只有文字大小，而我们的编辑框会占满剩余所有地方。

### 3.3.2 相对布局

RelativeLayout被称作相对布局，更加随意一点。

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent" android:layout_height="match_parent">

    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentTop="true"
        android:text="button1"
        />

    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentTop="true"
        android:text="button2"
        />
    
    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="button3"
        />
    
    <Button
        android:id="@+id/button4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentBottom="true"
        android:text="button4"
        />
    
    <Button
        android:id="@+id/button5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentBottom="true"
        android:text="button5"
        />
        
</RelativeLayout>
```

![1582789142151](\src\images\1582789142151.png)

以上代码非常好理解。所有空间都是对于父布局定位的，那么可不可以相对于控件进行定位呢。

```java
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent" android:layout_height="match_parent">

    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="button3"
        />
    
    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@id/button3"
        android:layout_toLeftOf="@id/button3"
        android:text="button1"
        />

    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@id/button3"
        android:layout_toRightOf="@id/button3"
        android:text="button2"
        />

    <Button
        android:id="@+id/button4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button3"
        android:layout_toLeftOf="@id/button3"
        android:text="button4"
        />

    <Button
        android:id="@+id/button5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button3"
        android:layout_toRightOf="@id/button3"
        android:text="button5"
        />

</RelativeLayout>
```

![1582789585155](\src\images\1582789585155.png)

还有其他的对齐方式例如alignLeft是左边缘对齐，alignRight是右边缘对齐，alignTop是上边缘对齐，alignBottom是下边缘对齐。要对齐的元素一定必须在xml上方定义。

### 3.3.3 帧布局

FrameLayout布局，又叫做帧布局。比起前两种简单很多，应用场景也少，没有便利的定位方式，所有控件都默认放在左上角。

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent" android:layout_height="match_parent">

    <TextView
        android:id="@+id/text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="This is my Text"
        />
    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@mipmap/ic_launcher"
</FrameLayout>
```

![1582790294684](\src\images\1582790294684.png)

图片挡住了文字，所有的都是左上角对齐。也可以使用layout_gravity进行对齐。但是使用的场景太少，不做赘述。

### 3.3.4 百分比布局

允许直接指定控件所占的百分比，百分比布局只提供了PercentFrameLayout和PercentRelativeLayout两种布局。

百分比布局是新定义的布局，无法直接在所有版本进行使用。Android团队将百分比布局定义到了support库之中。只需要在项目的build.gradle里面添加依赖即可。在dependence闭包加入这么一行：

```
compile 'com.android.support:percent:24.2.1'
```

接下来Sync Now即可。

## 3.4 创建自定义控件

下面关注控件和布局的继承结构：

<img src="\src\images\1582791998670.png" alt="1582791998670" style="zoom:50%;" />

所有的控件都直接或间接继承自View，所有的布局文件都是直接或者间接的继承ViewGroup。View可以画出一块矩形区域，并且可以响应这块区域的事件。ViewGroup是特殊的View，里面还有子View和子ViewGroup。

### 3.4.1 引入布局

我们将要创造我们自己的标题栏，新建title.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal" android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <Button
        android:id="@+id/button_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:text="Back"
        android:textColor="#fff"
        />

    <TextView
        android:id="@+id/title_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:layout_gravity="center"
        android:gravity="center"
        android:text="Title Text"
        android:textSize="24dp"
        />

    <Button
        android:id="@+id/title_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:text="edit"
        android:textColor="#fff"
     />

</LinearLayout>
```

这就是我们设计好的标题栏，只需在activity_main加入：

```
<include layout="@layout/title" />
```

就可以引入我们自定义的标题栏布局。然后我们需要将系统自带的标题栏隐藏掉：

```java
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ActionBar actionBar = getSupportActionBar();
        if(actionBar != null){
            actionBar.hide();
        }
    }
```

### 3.4.2 创建自定义控件

如果我们的布局中有一些控件需要有响应，但是我们还是要为这些事件注册代码，比如返回。这太过于麻烦。不管在哪个活动中，这个控件的功能相同，就是销毁当前的活动。因此最好的方式是通过自定义控件来解决。

新建TitleLayout来继承LinearLayout：

```java
public class TitleLayout extends LinearLayout {

    public TitleLayout(Context context, AttributeSet attrs){
        super(context,attrs);
        LayoutInflater.from(context).inflate(R.layout.title,this);
    }
}
```

在布局中引用TitleLayout的构造函数。在构造函数中需要对标题栏布局进行动态加载，就要借助LayoutInflater来实现。通过from方法构建出对象，调用inflate方法来动态加载一个布局文件。这里接收两个参数，一个是id，另一个是父布局，我们设定为this，指定为TitleLayout。

```xml
<com.example.uicustomviews.TitleLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
    />
```

使用这种方式就可以引用布局。添加时必须使用完整的包名。接下来就可以处理点击事件：

```java
public TitleLayout(Context context, AttributeSet attrs){
        super(context,attrs);
        LayoutInflater.from(context).inflate(R.layout.title,this);
        Button titleBack = (Button) findViewById(R.id.button_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);
        titleBack.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v) {
                //逻辑实现
            }
        });
        titleEdit.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v) {
                //逻辑实现
            }
        });
    }
```

## 3.5 最常用和最难用的控件——ListView

允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，原有的数据会滚出屏幕。

### 3.5.1 ListView的简单用法

```xml
<ListView
        android:id="@+id/list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        />
```

修改代码如下：

```java
public class MainActivity extends AppCompatActivity {

    private String data[] = {"Apple","Banana","Orange","Watermelon",
            "Pear", "Grape","Pineapple", "Strawberry", "Cherry", "Mango",
            "Apple","Banana","Orange","Watermelon",
            "Pear", "Grape","Pineapple", "Strawberry", "Cherry", "Mango",};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(MainActivity.this,
                android.R.layout.simple_expandable_list_item_1,data);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }
}
```

我们使用一组data数据进行测试。数据不能只能传递给listView，因此我们需要适配器。安卓提供了许多适配器的实现类。最好用的还是ArrayAdapter。可以利用泛型指定传入的数据类型，在构造函数中实现传入。接下来传入上下文，子项布局id，以及适配数据。子项布局是一个内置的布局id，里面只有一个TextView，可以简单的显示一段文本。

<img src="\src\images\1582856130929.png" alt="1582856130929" style="zoom:50%;" />

### 3.5.2 定制ListView界面

对ListView进行定制，可以显示更丰富的内容，我们要在水果旁边标上图样。首先定义实体类，作为适配器的适配类型：

```java
package com.example.uicustomviews;

public class Fruit {
    private String name;
    private int imageid;
    
    public Fruit(String name,int imageid){
        this.name = name;
        this.imageid = imageid;
    }

    public int getImageid() {
        return imageid;
    }

    public String getName() {
        return name;
    }
}
```

Fruit类只有两个字段，name和imageid。然后需要对我们的ListView子项自定义我们的布局

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal" android:layout_width="match_parent"
    android:layout_height="wrap_content">
    
    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="10dp"
        />
    
</LinearLayout>
```

接下来我们要自定义适配器，这个适配器继承自ArrayAdapter，并将泛型指为Fruit类，新建类FruitAdapter：

```java
public class FruitAdapter extends ArrayAdapter<Fruit> {
    
    private int resourceId;
    
    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context,textViewResourceId,objects);
        resourceId = textViewResourceId;
    }

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        Fruit fruit = getItem(position);
        View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitText = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageid());
        fruitText.setText(fruit.getName());
        return view;
    }
}
```

重写了父类的构造函数，把上下文，ListView的子项布局id以及数据都传递进来。另外重写了getView方法，这在每个子项被滚动到屏幕内时会调用。首先getItem方法得到当前的Fruit实例，然后使用LayoutInflater来加载我们的布局。inflate方法接收三个参数，第三个参数指定为false。表示只让我们在父布局中声明的Layout属性生效，但是不为这个View添加父布局，因为一旦View有了父布局，那么就不能添加到ListView之中。这是ListView的标准写法。

接下来通过findViewById获取实例，并显示图片和文字，最后把布局返回即可。这样自定义的适配器就完成了。

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item,fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }

    private void initFruits() {
        for (int i = 0; i < 2; i++){
            Fruit apple = new Fruit("Apple",R.drawable.apple);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana",R.drawable.banana);
            fruitList.add(banana);
            Fruit orange = new Fruit("orange",R.drawable.orange);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon",R.drawable.watermelon);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear",R.drawable.pear);
            fruitList.add(pear);
            Fruit pineapple = new Fruit("Pineapple",R.drawable.pineapple);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry",R.drawable.strawberry);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry",R.drawable.cherry);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango",R.drawable.mango);
            fruitList.add(mango);
        }
    }
}
```

inits方法用来初始化所有水果数据。Fruit类把数据传入，将适配器传入即可。

### 3.5.3 提升ListView效率

FruitAdapter的getView方法每次都将布局重新加载了一遍，当快速滚动的时候成为了性能的瓶颈。getView还有一个convertView参数，这个参数可以就已经加载好的布局进行缓存，代码更改如下：

```java
public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        Fruit fruit = getItem(position);
        View view;
        if(convertView == null){    
            view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);
        }
        else {
            view = convertView;
        }
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitText = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageid());
        fruitText.setText(fruit.getName());
        return view;
    }
```

还有继续优化的空间，虽然布局不会重新加载，但是我们每次还会调用findViewById来获取控件实例。我们可以借助ViewHolder来对这部分性能进行优化，修改代码：

```java
public class FruitAdapter extends ArrayAdapter<Fruit> {

    private int resourceId;

    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects){
        super(context,textViewResourceId,objects);
        resourceId = textViewResourceId;
    }

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        Fruit fruit = getItem(position);
        View view;
        ViewHolder viewHolder;
        if(convertView == null){
            view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);
            viewHolder = new ViewHolder();
            viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name);
            view.setTag(viewHolder);
        }
        else {
            view = convertView;
            viewHolder = (ViewHolder) view.getTag();
        }
        viewHolder.fruitImage.setImageResource(fruit.getImageid());
        viewHolder.fruitName.setText(fruit.getName());
        return view;
    }
    
    class ViewHolder{
        ImageView fruitImage;
        TextView fruitName;
    }
}
```

新建内部类viewHolder对控件实例进行缓存，当null的时候，创建对象，读取控件实例存放进去，当不为null的时候，可以直接取出，没有必要每次都通过findViewById来获取控件。这样我们的运行小效率就不错了。

### 3.5.4 ListView的点击事件

修改MainActivity中的代码：

```java
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item,fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                Fruit fruit = fruitList.get(position);
                Toast.makeText(MainActivity.this,fruit.getName(),Toast.LENGTH_SHORT).show();
            }
        });
    }
```

利用setOnItemClickListener注册监听器，当用户点击了ListView任何一个子项时，就会回调onItemClick方法，这个方法可以根据position参数判断用户点击的是哪个项，获取相应水果，并用Toast显示出来。

## 3.6 更强大的控件——RecyclerView

ListView性能差，扩展性不好，只能实现纵向滑动。因此要使用更强大的控件：RecyclerView。

### 3.6.1 RecyclerView的基本用法

这是新增的控件，为了在所有版本都能使用，加入到了support库之中。需要在项目的build.grade之中加入依赖库：在dependencies闭包加入

```
implementation 'androidx.recyclerview:recyclerview:1.0.0'
```

修改activity_main.xml文件：

```xml
<androidx.recyclerview.widget.RecyclerView
        android:id = '@+id/recycler_view'
        android:layout_width = 'match_parent'
        android:layout_height = 'match_parent'
        />
```

必须写入完整的包名。

接下来我们要准备一个适配器，新建FruitAdapter类，继承自Recycler.Adapter，并且将泛型指定为FruitAdapter.ViewHolder。其中ViewHolder是我们在FruitAdapter中定义的内部类。

```java
package com.example.recycleviewtest;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import java.util.List;

public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder{
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view){
            super(view);
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }

    public  FruitAdapter(List<Fruit> fruitList){
        mFruitList = fruitList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false);
        ViewHolder holder = new ViewHolder(view);
        return holder;
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }

    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
}

```

这一部分代码很长，但是很好理解。首先构造内部类ViewHolder，继承自Recycler.ViewHolder。然后ViewHolder构造函数要传入View参数，通常是子项最外层布局，通过findViewById来获取布局中的ImageView和TextView。

FruitAdapter也有一个构造函数，用于把要展示的数据传递进来。

接下来必须重写三个方法。onCreateViewHolder是用于创建ViewHolder实例的，将fruit_item加载进来，然后创建ViewHolder实例，并将加载出来的布局传入到构造函数中，最终将ViewHolder实例返回。onBindViewHolder实例对于子项进行赋值，通过position参数获得的Fruit实例传入holder中。getItemCount告诉一共有多少子项。

准备好之后开始使用RecycleHolder：

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruit();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }

    private void initFruit(){
        for (int i = 0; i < 2; i++){
            Fruit apple = new Fruit("Apple",R.drawable.apple);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana",R.drawable.banana);
            fruitList.add(banana);
            Fruit orange = new Fruit("orange",R.drawable.orange);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon",R.drawable.watermelon);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear",R.drawable.pear);
            fruitList.add(pear);
            Fruit pineapple = new Fruit("Pineapple",R.drawable.pineapple);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry",R.drawable.strawberry);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry",R.drawable.cherry);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango",R.drawable.mango);
            fruitList.add(mango);
        }
    }
}
```

LinearLayoutManager用来指定RecyclerView的布局，这里使用线性布局，和ListView一样的效果。最后将Fruit传入适配器。

### 3.6.2 实现横向布局和瀑布流布局

横向布局首先我们将fruit_item进行更改，改为纵向布局：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="100dp"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:layout_marginTop="10dp"
        />

</LinearLayout>
```

宽度设为100dp，防止有长有短。

```java
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruit();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }
```

之所以RecyclerView可以轻松设计布局得益于LayoutManager来管理布局。还有GridLayoutManager和StaggerdGridManager来管理瀑布流布局。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="5dp">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:layout_marginTop="10dp"
        />

</LinearLayout>
```

宽度match_parent，根据瀑布流的宽度自动适配。使用layout_margin让子项之间互留间距。TextView改为左对齐。

```java
package com.example.recycleviewtest;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.recyclerview.widget.StaggeredGridLayoutManager;

import android.os.Bundle;
import android.view.View;
import android.widget.LinearLayout;

import java.util.ArrayList;
import java.util.List;

public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruit();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        StaggeredGridLayoutManager layoutManager = new
                StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }

    private void initFruit(){
        for (int i = 0; i < 2; i++){
            Fruit apple = new Fruit("Apple",R.drawable.apple);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana",R.drawable.banana);
            fruitList.add(banana);
            Fruit orange = new Fruit("orange",R.drawable.orange);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon",R.drawable.watermelon);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear",R.drawable.pear);
            fruitList.add(pear);
            Fruit pineapple = new Fruit("Pineapple",R.drawable.pineapple);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry",R.drawable.strawberry);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry",R.drawable.cherry);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango",R.drawable.mango);
            fruitList.add(mango);
        }
    }
}
```

创建了StaggerGridLayoutManager实例，分为3列，并且对象为竖向。

### 3.6.3 RecyclerView的点击事件

RecyclerView没有提供注册监听器的方法。因此需要修改我们的FruitAdapter代码：

```java
package com.example.recycleviewtest;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import java.util.List;

public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder{
        View fruitView;
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view){
            super(view);
            fruitView = view;
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }

    public  FruitAdapter(List<Fruit> fruitList){
        mFruitList = fruitList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false);
        final ViewHolder holder = new ViewHolder(view);
        holder.fruitView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(),"you click view "+fruit.getName(),Toast.LENGTH_SHORT).show();
            }
        });
        holder.fruitImage.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(),"you click image "+fruit.getName(),Toast.LENGTH_SHORT).show();
            }
        });
        return holder;
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }

    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
}
```

在ViewHolder中添加了fruitView变量来保存子项外层布局实例。之后进行注册就可以了。我们可以获取不同的点击，拿到响应的实例，用Toast显示内容。

## 3.7 编写界面的最佳实践

编写复杂优美的聊天界面。创建UIBestPractice。

### 3.7.1 制作Nine-Patch图片

被特殊处理的PNG，可以指定哪些区域可以被拉伸。

![1583064997729](\src\images\1583064997729.png)

左上表示拉伸区域，右下表示内容存放区域。

### 3.7.2 编写精美的聊天界面

我们要使用RecyclerView这个库，需要先导入进去。接下来修改activity_main.xml的代码：

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#d8e0e8">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/msg_recycler_view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        
        <EditText
            android:id="@+id/input_text"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="请输入文字"
            android:maxLines="2"
            />
    
        <Button
            android:id="@+id/send"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="send"
            />
    
    </LinearLayout>            


</LinearLayout>
```

创建了RecyclerView来放置类聊天内容，防止一个EditText来输入消息，防止Button来放置消息：

定义消息的实体类：

```java
public class msg {
    public static final int TYPE_RECIEVED = 0;
    public static final int TYPE_SENT = 1;
    
    private String content;
    private int Type;
    
    public msg(String content, int Type){
        this.content = content;
        this.Type = Type;
    }

    public String getContent() {
        return content;
    }

    public int getType() {
        return Type;
    }
}
```

有两个字段，一个是内容，一个是类型。接下来来编辑Recycle子项布局：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="10dp">

    <LinearLayout
        android:id="@+id/left_layout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:background="@drawable/left">

        <TextView
            android:id="@+id/right_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp"
            android:textColor="#fff"
            />
    </LinearLayout>

    <LinearLayout
        android:id="@+id/right_layout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:background="@drawable/right">

        <TextView
            android:id="@+id/left_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp"
            android:textColor="#fff"
            />
    </LinearLayout>

</LinearLayout>
```

我们使用VISIBLE参数来控制哪个对话框来显示。

新建MsgAdapter：

```java
public class MsgAdapter extends RecyclerView.Adapter<MsgAdapter.ViewHolder> {

    private List<msg> mMsgList;

    static class ViewHolder extends RecyclerView.ViewHolder{
        LinearLayout leftLayout;
        LinearLayout rightLayout;
        TextView leftMsg;
        TextView rightMsg;

        public ViewHolder(View view){
            super(view);
            leftLayout = view.findViewById(R.id.left_layout);
            rightLayout = view.findViewById(R.id.right_layout);
            leftMsg = view.findViewById(R.id.left_msg);
            rightMsg = view.findViewById(R.id.right_msg);
        }
    }

    public MsgAdapter(List<msg> msgList){
        mMsgList = msgList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item,parent,false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        msg m = mMsgList.get(position);
        if(m.getType()==msg.TYPE_RECIEVED){
            holder.leftLayout.setVisibility(View.VISIBLE);
            holder.rightLayout.setVisibility(View.GONE);
            holder.leftMsg.setText(m.getContent());
        }
        if(m.getType()==msg.TYPE_SENT){
            holder.leftLayout.setVisibility(View.GONE);
            holder.rightLayout.setVisibility(View.VISIBLE);
            holder.rightMsg.setText(m.getContent());
        }
    }

    @Override
    public int getItemCount() {
        return mMsgList.size();
    }
}
```

最后修改MainActivity代码：

```java
public class MainActivity extends AppCompatActivity {

    private List<msg> msgList = new ArrayList<>();

    private EditText inputText;

    private Button send;

    private RecyclerView msgRecyclerView;

    private MsgAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initMsg();
        inputText = (EditText) findViewById(R.id.input_text);
        send = (Button)findViewById(R.id.send);
        msgRecyclerView = (RecyclerView) findViewById(R.id.msg_recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        msgRecyclerView.setLayoutManager(layoutManager);
        adapter = new MsgAdapter(msgList);
        msgRecyclerView.setAdapter(adapter);
        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String content = inputText.getText().toString();
                if(!"".equals(content)){
                    msg m = new msg(content,msg.TYPE_SENT);
                    msgList.add(m);
                    adapter.notifyItemInserted(msgList.size()-1);
                    msgRecyclerView.scrollToPosition(msgList.size()-1);
                    inputText.setText("");
                } else {
                    Toast.makeText(MainActivity.this,"请输入内容",Toast.LENGTH_SHORT).show();
                }
            }
        });
    }

    private void initMsg(){
        msg msg1 = new msg("Hello,guy",msg.TYPE_RECIEVED);
        msgList.add(msg1);
        msg msg2 = new msg("Hello, who is that?",msg.TYPE_SENT);
        msgList.add(msg2);
        msg msg3 = new msg("This is Tom, Nice to Meet you",msg.TYPE_RECIEVED);
        msgList.add(msg3);
    }
}
```

